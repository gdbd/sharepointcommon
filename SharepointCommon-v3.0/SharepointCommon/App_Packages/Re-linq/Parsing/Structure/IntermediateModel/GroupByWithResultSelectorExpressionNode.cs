// Copyright (c) rubicon IT GmbH, www.rubicon.eu
//
// See the NOTICE file distributed with this work for additional information
// regarding copyright ownership.  rubicon licenses this file to you under 
// the Apache License, Version 2.0 (the "License"); you may not use this 
// file except in compliance with the License.  You may obtain a copy of the 
// License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the 
// License for the specific language governing permissions and limitations
// under the License.
// 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Remotion.Linq.Parsing.ExpressionVisitors;
using Remotion.Linq.Utilities;
using Remotion.Utilities;

namespace Remotion.Linq.Parsing.Structure.IntermediateModel
{
  /// <summary>
  /// Represents a <see cref="MethodCallExpression"/> for the different <see cref="Queryable.GroupBy{TSource, TKey}(IQueryable{TSource}, Expression{Func{TSource, TKey}})"/> 
  /// overloads that do take a result selector. The overloads without a result selector are represented by 
  /// <see cref="GroupByExpressionNode"/>.
  /// It is generated by <see cref="ExpressionTreeParser"/> when an <see cref="Expression"/> tree is parsed.
  /// </summary>
  /// <remarks>
  /// The GroupBy overloads with result selector are parsed as if they were a <see cref="SelectExpressionNode"/> following a 
  /// <see cref="GroupByExpressionNode"/>:
  /// <code>
  /// x.GroupBy (k => key, e => element, (k, g) => result)
  /// </code>
  /// is therefore equivalent to:
  /// <code>
  /// c.GroupBy (k => key, e => element).Select (grouping => resultSub)
  /// </code>
  /// where resultSub is the same as result with k and g substituted with grouping.Key and grouping, respectively.
  /// </remarks>
  public sealed class GroupByWithResultSelectorExpressionNode : IQuerySourceExpressionNode
  {
    public static IEnumerable<MethodInfo> GetSupportedMethods()
    {
      return ReflectionUtility.EnumerableAndQueryableMethods.WhereNameMatches ("GroupBy").WithResultSelector().WithoutEqualityComparer();
    }

    private readonly SelectExpressionNode _selectExpressionNode;

    public GroupByWithResultSelectorExpressionNode (
        MethodCallExpressionParseInfo parseInfo, 
        LambdaExpression keySelector, 
        LambdaExpression elementSelectorOrResultSelector, 
        LambdaExpression resultSelectorOrNull)
    {
      ArgumentUtility.CheckNotNull ("keySelector", keySelector);
      ArgumentUtility.CheckNotNull ("elementSelectorOrResultSelector", elementSelectorOrResultSelector);

      _selectExpressionNode = new SelectExpressionNode (
          CreateParseInfoWithGroupNode (parseInfo, keySelector, elementSelectorOrResultSelector, resultSelectorOrNull),
          CreateSelectorForSelectNode (keySelector, elementSelectorOrResultSelector, resultSelectorOrNull));
    }

    private static MethodCallExpressionParseInfo CreateParseInfoWithGroupNode (
        MethodCallExpressionParseInfo parseInfo, 
        LambdaExpression keySelector, 
        LambdaExpression elementSelectorOrResultSelector, 
        LambdaExpression resultSelectorOrNull)
    {
      var optionalElementSelector = GetOptionalElementSelector (elementSelectorOrResultSelector, resultSelectorOrNull);

      var sourceItemType = ReflectionUtility.GetItemTypeOfClosedGenericIEnumerable (
          parseInfo.ParsedExpression.Arguments[0].Type, 
          "parseInfo.ParsedExpression.Arguments[0].Type");

      MethodCallExpression simulatedGroupByCallWithoutResultSelector;
      if (optionalElementSelector == null)
      {
        simulatedGroupByCallWithoutResultSelector = Expression.Call (
            typeof (Enumerable),
            "GroupBy",
            new[] { sourceItemType, keySelector.Body.Type },
            parseInfo.ParsedExpression.Arguments[0],
            keySelector);
      }
      else
      {
        simulatedGroupByCallWithoutResultSelector = Expression.Call (
            typeof (Enumerable),
            "GroupBy",
            new[] { sourceItemType, keySelector.Body.Type, optionalElementSelector.Body.Type },
            parseInfo.ParsedExpression.Arguments[0],
            keySelector,
            optionalElementSelector);
      }

      var simulatedParseInfo = new MethodCallExpressionParseInfo(parseInfo.AssociatedIdentifier, parseInfo.Source, simulatedGroupByCallWithoutResultSelector);
      var groupBySourceNode = new GroupByExpressionNode (simulatedParseInfo, keySelector, optionalElementSelector);
      return new MethodCallExpressionParseInfo (parseInfo.AssociatedIdentifier, groupBySourceNode, parseInfo.ParsedExpression);
    }

    private static LambdaExpression CreateSelectorForSelectNode (
        LambdaExpression keySelector, 
        LambdaExpression elementSelectorOrResultSelector, 
        LambdaExpression resultSelectorOrNull)
    {
      var resultSelector = GetResultSelector (elementSelectorOrResultSelector, resultSelectorOrNull);
      var optionalElementSelector = GetOptionalElementSelector (elementSelectorOrResultSelector, resultSelectorOrNull);

      // If there is an element selector, the element type will be that returned by the element selector. Otherwise, it will be the type flowing into
      // the key selector.
      var elementType = optionalElementSelector != null ? optionalElementSelector.Body.Type : keySelector.Parameters[0].Type;
      var groupingType = typeof (IGrouping<,>).MakeGenericType (keySelector.Body.Type, elementType);
      var keyProperty = groupingType.GetRuntimeProperty ("Key");

      var groupParameter = Expression.Parameter (groupingType, "group");
      var keyExpression = Expression.MakeMemberAccess (groupParameter, keyProperty);

      var expressionMapping = new Dictionary<Expression, Expression> (2)
                              {
                                  { resultSelector.Parameters[1], groupParameter },
                                  { resultSelector.Parameters[0], keyExpression }
                              };
      var bodyWithGroupingAndKeyReplaced = MultiReplacingExpressionVisitor.Replace (expressionMapping, resultSelector.Body);
      return Expression.Lambda (bodyWithGroupingAndKeyReplaced, groupParameter);
    }

    private static LambdaExpression GetOptionalElementSelector (LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull)
    {
      return resultSelectorOrNull == null ? null : elementSelectorOrResultSelector;
    }

    private static LambdaExpression GetResultSelector (LambdaExpression elementSelectorOrResultSelector, LambdaExpression resultSelectorOrNull)
    {
      if (resultSelectorOrNull != null)
      {
        if (resultSelectorOrNull.Parameters.Count != 2)
          throw new ArgumentException ("ResultSelector must have exactly two parameters.", "resultSelectorOrNull");

        return resultSelectorOrNull;
      }
      else
      {
        if (elementSelectorOrResultSelector.Parameters.Count != 2)
          throw new ArgumentException ("ResultSelector must have exactly two parameters.", "elementSelectorOrResultSelector");
        return elementSelectorOrResultSelector;
      }
    }

    public IExpressionNode Source
    {
      get { return _selectExpressionNode.Source; }
    }

    public string AssociatedIdentifier
    {
      get { return _selectExpressionNode.AssociatedIdentifier; }
    }

    public Expression Selector
    {
      get { return _selectExpressionNode.Selector; }
    }

    public Expression Resolve (ParameterExpression inputParameter, Expression expressionToBeResolved, ClauseGenerationContext clauseGenerationContext)
    {
      ArgumentUtility.CheckNotNull ("inputParameter", inputParameter);
      ArgumentUtility.CheckNotNull ("expressionToBeResolved", expressionToBeResolved);

      return _selectExpressionNode.Resolve (inputParameter, expressionToBeResolved, clauseGenerationContext);
    }

    public QueryModel Apply (QueryModel queryModel, ClauseGenerationContext clauseGenerationContext)
    {
      ArgumentUtility.CheckNotNull ("queryModel", queryModel);

      return _selectExpressionNode.Apply (queryModel, clauseGenerationContext);
    }
  }
}
